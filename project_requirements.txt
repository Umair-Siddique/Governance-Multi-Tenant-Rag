Technical Implementation Document 
Governance‑Safe Multi‑Tenant AI SaaS Platform 
1. Objective and Scope Alignment 
This document explains how the full set of requirements provided by the client will be 
implemented technically, using the agreed technology stack: 
• Supabase (PostgreSQL) – primary database and authentication 
• Pinecone – vector database 
• Python (Flask) – backend services and orchestration 
• React – frontend (Admin + End‑User UI) 
• Render – backend deployment 
• Vercel – frontend deployment 
The implementation strictly follows the attached scope document. No additional 
features, assumptions, or extensions are introduced beyond what is explicitly required. 
2. High‑Level System Architecture 
The platform is implemented as a multi‑tenant SaaS system where each tenant 
represents one isolated organization (e.g. a government institution). 
Key characteristics: 
• Single shared application stack 
• Strong tenant isolation at database and vector layers 
• Governance‑first RAG architecture 
• AI never accesses external or unapproved data 
All tenant data is isolated and never shared. 
3. Multi‑Tenant Architecture & Isolation 
3.1 Tenant Model 
• Each tenant has a unique tenant_id 
• All requests (API, vector search, CMS actions) are always executed in a 
tenant‑scoped context 
• No global or cross‑tenant queries exist 
3.2 Database Isolation (Supabase / PostgreSQL) 
Isolation is enforced at the database level, not only via application logic. 
Approach: 
• PostgreSQL with strict Row Level Security (RLS) per table 
• Every row is bound to a tenant_id 
• RLS policies ensure: 
o A tenant can only read/write its own rows 
o Cross‑tenant access is technically impossible 
This guarantees that Tenant A cannot access Tenant B data even in case of 
application‑level bugs. 
3.3 Vector Isolation (Pinecone) 
• Each tenant has a dedicated Pinecone namespace (or index) 
• Embeddings are written and queried only within the tenant’s namespace 
• No shared vector storage 
Cross‑tenant vector retrieval is technically impossible. 
4. Tenant Operating Modes 
The system includes a first‑class tenant_type concept, enforced in backend logic and 
policies. 
4.1 Default Operating Model 
For this build, BYO‑LLM (self‑managed tenants) is the default and primary operating 
mode. 
• Tenants are expected to provide their own LLM API keys by default 
• Platform‑managed LLM credentials are considered optional / future tier, not the 
default 
All tenant types share identical governance, RAG enforcement, and isolation logic. 
4.2 Supported Tenant Types 
Self‑Managed Tenant (BYO‑LLM – Default) 
• Tenant provides its own LLM API key (OpenAI / Anthropic / Mistral) 
• Keys stored encrypted in Supabase 
• Keys used server‑side only 
• Same governance, isolation, and RAG enforcement 
Managed Tenant (Optional / Future Tier) 
• Platform‑managed LLM credentials 
• Platform bears model usage cost 
• Full governance enforcement 
White‑Label Tenant 
• Can be Managed or BYO‑LLM 
• Branding and feature limits applied 
• Intended for institutional or reseller use 
4.3 Enforcement 
Tenant type controls: 
• How LLM credentials are resolved 
• Rate limits and usage limits 
• Feature visibility 
• Analytics visibility 
This is enforced centrally in backend services (not UI flags). 
5. Identity, Authentication & Roles 
5.1 Authentication Methods 
The platform supports multiple authentication methods, all tenant‑scoped and enforced 
backend‑side: 
• Standard email/password authentication 
• Microsoft Entra ID (Azure AD) SSO 
• Google Sign‑In (OAuth) 
All users and tenants are always linked to a verified email address. 
5.1 Authentication 
• Supabase Authentication used for identity management 
• Secure password hashing and salting 
• Tenant‑scoped users 
5.2 Roles 
Minimum roles implemented: 
• Admin 
• Editor (Uploader) 
• Reviewer (Approver) 
• User (End‑user) 
Role permissions are enforced backend‑side. 
5.3 Role‑Based Workflow (as discussed) 
• Uploader (Editor) uploads documents 
• Reviewer reviews and approves documents 
• Only Approved content becomes AI‑accessible 
• End‑users can only query approved data 
5.4 Single Sign‑On (Microsoft Entra ID / Azure AD) 
In addition to local authentication, the platform supports institutional Single Sign‑On 
using Microsoft Entra ID, as required. 
Technical approach: 
• Integration via OIDC or SAML, depending on tenant preference 
• SSO configuration is tenant‑scoped 
• Supabase acts as the identity broker 
• No local passwords for SSO users 
Role mapping: 
• Azure AD groups are mapped to platform roles 
• Role enforcement remains backend‑controlled 
5.5 Google Sign‑In & Email‑Based Flows 
Google Sign‑In (OAuth) 
• Tenant‑configurable Google OAuth integration 
• Users authenticate using verified Google accounts 
Email‑based governance flows: 
• Email verification on registration 
• Welcome / account activation emails 
• Tenant invite emails 
• Role assignment notification emails 
All users must have a verified email address before accessing the system. 
6. CMS & Content Governance 
6.1 CMS Functionality 
Each tenant has a dedicated CMS allowing: 
• Upload of documents 
• Text content management 
• Editing and deletion 
6.2 Mandatory Content Lifecycle 
All content follows this lifecycle: 
1. Draft 
2. Review 
3. Approved / Published 
Critical enforcement: 
• AI can access Approved content only 
• Draft and Review content is never embedded or indexed 
6.3 Versioning & Auditability 
• Each content update creates a new version 
• Actor and timestamp recorded 
• Rollback to previous version supported 
7. Document Upload, Multi‑Type Handling & Batch 
Governance 
The platform supports multiple document formats (PDF, DOCX, CSV, TXT, etc.). 
7.1 Why Different Handling Is Required 
• PDFs and DOCX are text‑flow based 
• CSV files are structured (rows / columns) 
• Each format requires format‑specific parsing before chunking 
7.2 Processing Pipeline (Format‑Aware) 
For institutional uploads (CMS), documents are processed using a format‑aware 
pipeline to ensure accuracy, governance, and scalability: 
• PDF / DOCX: text extraction → logical section detection → normalization 
• CSV: column‑aware parsing → row/field normalization 
• TXT: direct text normalization 
Background Processing for Large Documents 
• Large documents and bulk uploads are processed using a separate background 
worker service deployed on Render. 
• The main Flask API remains responsive and only orchestrates jobs. 
• Background workers handle: 
o heavy parsing 
o OCR execution 
o text normalization 
o chunking 
o embedding generation 
This ensures: 
• no API timeouts 
• predictable performance 
• safe handling of very large files 
Content Normalization & Cleaning Layer 
Before chunking and embedding, all extracted text (from PDFs or OCR) passes through a 
normalization and cleaning layer: 
• Removal of corrupted characters, headers, footers, page numbers 
• Removal of OCR noise, repeated sentences, and irrelevant artifacts 
• Structural cleanup (paragraph consistency, sentence boundaries) 
This step may use LLM‑assisted text cleaning in a controlled, non‑generative mode: 
• The LLM is used only to clean and normalize extracted text 
• No new information is added 
• No interpretation or rewriting occurs 
Final Indexing Flow (After Reviewer Approval) 
Only after Reviewer approval does the system execute: 
Upload → Format‑specific parsing → Cleaning & normalization → Chunking → Embeddings → 
Pinecone (tenant namespace) 
Batch Governance for Large Imports 
For bulk and SharePoint‑based imports, the system supports batch governance actions: 
• Batch approval and batch rejection of documents 
• Single action applies to hundreds or thousands of documents 
Audit logging: 
• Batch actions recorded as a single governance event 
• Logs include batch identifier, document count, actor, and timestamp 
This ensures institutional‑scale workflows without per‑document manual approval. 
8. End‑User Chat With Temporary File Uploads 
As discussed in the call: 
• End‑users may upload a document inside the chat 
• These documents are: 
o Used only for temporary reference 
o Never stored in the CMS 
o Never embedded 
o Never added to Pinecone 
8.1 Usage Example 
• User uploads a protocol document 
• Asks a question comparing it to official data 
• System uses: 
o The uploaded document as context only 
o The approved tenant dataset for answers 
The system does not learn, store, or index user‑uploaded chat documents. 
9. RAG Pipeline, LLM Abstraction & Hallucination 
Prevention 
9.0 LLM Provider Abstraction 
LLM access is implemented via a provider‑agnostic abstraction layer. 
Supported providers: 
• OpenAI 
• Anthropic 
• Mistral 
Key properties: 
• Provider selection is tenant‑scoped 
• No provider‑specific assumptions in core logic 
• Governance, refusal logic, and RAG enforcement remain identical across providers 
9.1 Retrieval Enforcement 
All retrieval is strictly scoped to: 
• Current tenant 
• Approved content only 
• Tenant’s Pinecone namespace 
No external data sources are ever used. 
9.2 Answer Validation 
• Answers are generated only from retrieved chunks 
• Source citations are attached 
• If coverage is insufficient → full refusal 
9.3 Refusal Logic 
The system refuses: 
• Questions outside the dataset 
• Legal advice 
• Case evaluation 
• Interpretation or opinion 
Refusals use fixed templates and are language‑specific. 
10. Multilingual Support 
10.1 Supported Languages 
All required languages are supported: 
Arabic, Tigrinya, Farsi, Dari, Pashto, Turkish, Somali, English, French, Dutch 
10.2 Enforcement 
• Language is explicitly selected by the user 
• No auto‑detection 
• No language mixing 
• Low‑confidence languages trigger refusal 
11. OCR, BYO‑OCR & Document Explanation 
11.1 OCR Architecture & BYO‑OCR (First‑Class) 
OCR is implemented as a first‑class, tenant‑configurable service, similar to BYO‑LLM. 
Supported OCR modes (per tenant): 
• Self‑hosted CPU OCR (Tesseract / PaddleOCR) 
• Self‑hosted GPU OCR 
• OCR via API (e.g. Mistral OCR or comparable GPU‑based services) 
BYO‑OCR support: 
• Tenants may provide their own OCR API keys 
• Keys are stored encrypted 
• OCR provider selection is: 
o tenant‑scoped 
o policy‑enforced 
o usable in white‑label deployments 
This enables high‑volume or reseller tenants to use GPU‑based OCR without refactoring 
the platform. 
11.2 OCR Flow 
Upload → OCR (background worker) → Text cleaning & normalization → Chunking → 
Embeddings → Tenant Pinecone index 
OCR output always passes through the same cleaning layer to remove useless sentences, 
noise, and artifacts before indexing. 
Deletion removes all derived data. 
Upload → OCR → Chunking → Embeddings → Tenant Pinecone index 
Deletion removes all derived data. 
11.3 Explanation Rules 
• Summary 
• Definitions 
• Paragraph references 
• No interpretation or advice 
12. Analytics, Policies & Audit Logs 
12.1 Tenant Policies 
Configurable per tenant: 
• Chat retention 
• Logging depth 
• Analytics depth 
• OCR retention 
Policies enforced server‑side. 
12.2 Analytics 
• Aggregated tenant‑level only 
• No user‑level tracking 
• Usage, language distribution, refusal rates 
12.3 Audit Logs 
• Immutable 
• Tenant‑scoped 
• Content, policy, and admin actions 
13. UI & White‑Label Readiness 
13.1 UI Separation 
• End‑user chat UI 
• Admin & governance UI 
13.2 White‑Label Support & Governance Resale 
White‑label readiness is implemented at routing, configuration, and theming levels, 
without requiring code changes per tenant. 
White‑label tenants may themselves serve institutional customers. 
All governance‑grade capabilities apply identically under white‑label tenants, including: 
• BYO‑LLM 
• BYO‑OCR 
• SSO (Entra ID, Google) 
• Approval workflows 
• Audit logging 
• Tenant isolation and RAG enforcement 
No reduction in governance guarantees is permitted for white‑label usage. 
14. Content Import & Institutional Integration 
14.1 SharePoint Bulk Import (Read‑Only) 
To meet the institutional integration requirement, the platform includes a SharePoint bulk 
importer. 
Technical approach: 
• Read‑only access to a SharePoint document library 
• Folder structure is mapped to CMS categories 
• Import can be triggered manually or on a scheduled basis 
Batch governance support: 
• Imported documents can be approved or rejected in batches 
• Batch actions are audited as a single governance event 
14.1 SharePoint Bulk Import (Read‑Only) 
To meet the institutional integration requirement, the platform includes a SharePoint bulk 
importer. 
Technical approach: 
• Read‑only access to a SharePoint document library 
• Folder structure is mapped to CMS categories 
• Import can be triggered manually or on a scheduled basis 
Governance enforcement: 
• Imported content always enters the CMS in Draft state 
• Review and approval are required before any document is indexed 
• Only Approved content is embedded and stored in Pinecone 
Update & deletion handling: 
• Updates or deletions in SharePoint are reflected in the CMS 
• Corresponding embeddings are updated or removed from the tenant namespace 
This approach ensures SharePoint content follows the same governance lifecycle as 
manually uploaded documents. 
15. Deployment, Hosting Neutrality & Infrastructure 
The architecture is cloud‑agnostic and designed to operate across AWS, Render, Azure, or 
mixed environments. 
EU‑only deployment is supported where required, but not hard‑coded as a mandatory 
constraint. 
Hosting neutrality ensures future institutional adoption without architectural changes. 
• Backend: Flask on Render 
• Frontend: React on Vercel 
• Environments: Dev, Staging, Production 
• EU‑only hosting 
Infrastructure‑as‑Code and deployment documentation provided. 
15. Security & Compliance 
• Encryption at rest and in transit 
• Encrypted API keys 
• GDPR‑compliant 
• No personal data profiling 
• No cross‑tenant analytics 
16. Intellectual Property & Handover 
• Full IP ownership transferred to client 
• Full repository handover 
• Deployment documentation 
• Knowledge transfer session 
• No vendor lock‑in 
17. Delivery & Acceptance 
Delivery is accepted only when: 
• All features function as specified 
• Governance is enforced technically 
• No scope deviations 
18. Milestone Plan, Timeline & Budget 
The project will be delivered in 4 structured milestones, covering all technical 
requirements end‑to‑end. The total timeline is 2 months, 
divided evenly across milestones. 
Each milestone includes concrete technical implementation and validation. Deployment 
and CI/CD setup begin from Milestone 1 and evolve progressively. 
Milestone 1 — Core Architecture, Multi‑Tenancy & CI/CD Setup 
Timeline: Weeks 1–2 

Technical Deliverables: 
• Supabase project setup (PostgreSQL + Auth) 
• Tenant data model and tenant_id strategy 
• Database isolation using strict Row Level Security (RLS) 
• Pinecone setup with tenant‑level namespaces 
• Flask backend base architecture 
• CI/CD pipelines configured for backend (Render) and frontend (Vercel) 
• Initial deployment of backend and frontend environments (Dev) 
Outcome: 
A running multi‑tenant foundation with enforced isolation, automated deployments, and 
environment separation. 
Milestone 2 — CMS, Roles, Document Upload & Processing Pipeline 
Timeline: Weeks 3–4 

Technical Deliverables: 
• Role‑based access control (Admin, Editor, Reviewer, User) 
• CMS for document upload, edit, delete 
• Draft → Review → Approved content lifecycle 
• Background worker service on Render for large document processing 
• Format‑aware document parsing (PDF, DOCX, CSV, JPG) 
• Text normalization & LLM‑assisted cleaning layer 
• Secure storage of approved content metadata 
Outcome: 
A fully governed content ingestion system where only reviewed and approved documents 
can enter the AI pipeline. 
Milestone 3 — RAG Pipeline, Chat, OCR & Multilingual Enforcement 
Timeline: Weeks 5–6 
Technical Deliverables: 
• RAG pipeline scoped to tenant + approved content only 
• Pinecone embedding and retrieval enforcement 
• Hallucination prevention with strict refusal logic 
• Source attribution in responses 
• End‑user chat interface 
• Temporary chat document upload (reference‑only, non‑indexed) 
• OCR service integration with background workers 
• Multilingual support and language enforcement rules 
Outcome: 
A governance‑safe AI system that answers strictly from approved data, refuses unsafe 
questions, and supports all required languages. 
Milestone 4 — White‑Label, Policies, Analytics & Final Hardening 
Timeline: Weeks 7–8 

Technical Deliverables: 
• White‑label implementation with wildcard subdomain routing 
• Dynamic branding (logo, app name, colors) 
• Tenant policy configuration (retention, logging, analytics depth) 
• Aggregated tenant‑level analytics 
• Immutable audit logs 
• Security hardening and final validation 
• Production deployment and environment verification 
• Documentation and handover preparation 
Outcome: 
A production‑ready, white‑label, multi‑tenant AI SaaS platform that meets all governance, 
security, and acceptance requirements. 



1. Cross-milestone (currently missing entirely) 
These items are not clearly anchored in any milestone but must be part of v1: 
• BYO-Key as default tenant mode 
o Tenants must provide their own API keys for: 
▪ LLM (OpenAI / Anthropic / Gemini / etc.) 
▪ OCR provider (CPU OCR by default, optional GPU/API OCR such as Mistral) 
o Keys must be: 
▪ Encrypted at rest 
▪ Used server-side only 
▪ Isolated per tenant 
o Platform must not incur variable LLM or OCR costs for tenants 
• LLM & OCR provider abstraction layer 
o Clean interface so providers can be swapped without refactoring 
o No hard dependency on a single LLM or OCR vendor 
• Email governance 
o Mandatory email verification on signup 
o Emails sent for: 
▪ Account creation 
▪ Tenant invitation 
▪ Role assignment 
▪ Password reset 
o All users must be email-linked 
• Unlimited revisions within scope 
o Revisions are unlimited as long as they stay within the agreed scope 
o No numeric revision caps per milestone 
2. Milestone 1 – Core Architecture & CI/CD 
Missing or unclear: 
• Explicit confirmation that: 
o BYO-LLM is already functional in Milestone 1 
o No platform-owned LLM keys are required to run the system 
• Tenant isolation must be demonstrated for: 
o Database 
o Vector store 
• Clear acceptance criteria: 
o Proof that tenant A cannot retrieve data from tenant B (not just configuration) 
3. Milestone 2 – CMS & Document Pipeline 
Missing or insufficiently specified: 
• Batch imports 
o Support for bulk uploads of hundreds or thousands of documents 
o Background workers must handle large batches without UI blocking 
• Batch approval / rejection 
o Admins must be able to approve or reject documents in bulk 
o No per-document manual approval required for large imports 
• Audit logging for batch actions 
o Batch approvals/rejections logged as: 
▪ Single governance action 
▪ With batch ID and document count 
4. Milestone 3 – RAG, OCR & Multilingual 
Missing or needs clarification: 
• Temporary user document uploads 
o Must be explicitly confirmed as: 
▪ Non-indexed 
▪ Non-persistent 
▪ Used only for the current session/question 
• OCR confidence handling 
o Even if true “accuracy scoring” is impossible, the system must: 
▪ Flag low-quality OCR output based on heuristics (empty text, noise, low word 
count, etc.) 
▪ Require human approval before such documents are indexed 
• Language priorities 
o Explicit confirmation that v1 priority languages are: 
▪ Arabic, English, French, Dutch, German and Spanish 
5. Milestone 4 – White-Label, Policies & Hardening 
Missing or insufficiently explicit: 
• White-label guarantees 
o Tenant branding must be: 
▪ First-class (not UI hacks) 
▪ Applied consistently across app and subdomain 
o Subdomain routing must be stable and production-ready 
• Policy enforcement 
o Policies must be enforced backend-side, not UI-only: 
▪ Chat retention 
▪ Logging level 
▪ Analytics depth 
▪ OCR storage & deletion 
• IP ownership 
o Explicit confirmation that: 
▪ All source code 
▪ Infrastructure scripts 
▪ Prompts and configurations 
transfer fully to me upon milestone acceptance and payment 
6. Out-of-scope clarity (must be stated) 
To avoid confusion later, please explicitly confirm as out of scope for this AppSumo / BYO-key version: 
• Government-grade compliance certifications 
• Azure-only or EU-sovereign deployment guarantees 
• Custom OCR model training 
• Billing systems or AppSumo integrations 
• Enterprise SSO beyond Google Sign-In 